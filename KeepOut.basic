1 hgr
2 HCOLOR = 3
3 PI = 3.141592653
4 xscreen = 280
5 yscreen = 192
6 e = rnd(-1192)

30 dim triangles(12*20)
40 ntriangles = 0
50 dim rectangles(16*20)
60 nrectangles = 0
61 rem to draw a triangle, add the relevant points to triangles -
62 rem x1,y1,z1,x2,y2,z2,x3,y3,z3 - and increment ntriangles
63 rem drawing a rectangle is the analagous with appropriate variables
64 rem the arrays have space for 20 at once

70 xcamera = 0
80 ycamera = 0
90 zcamera = 5
100 yrot = 0
110 FOV = 120
101 rem choosing to ignore x and z rotation as they are not needed for this
102 rem rotation of 0 is in the +z direction; angles are 0-2Ï€
103 rem FOV is linear and represents how many px a meter is

120 dim map(30*30*2)
121 rem represents the map; 0 = wall, 1 = clear, 2 = enemy, 3 = gold
130 difficulty = 0.99
140 gosub 4000
150 for r=0 to 29
160 for c=0 to 29
170 if maze(30*r+c) == 1 then print " ";
180 if maze(30*r+c) >< 1 then print "#";
190 next c
200 print ""
210 next r
220 end

4000 rem subroutine that generates a level
4010 rem operates on the lists "objects" and "map"
4020 rem takes difficulty as input (0 - 1)
4030 dim snakes(5*2)
4040 snakes(0) = 0
4050 snakes(1) = 0
4060 snakes(2) = -1: snakes(3) = -1: snakes(4) = -1: snakes(5) = -1: snakes(6) = -1: snakes(7) = -1: snakes(8) = -1: snakes(9) = -1:

4080 for s=0 to 4
4090 if snakes(s*2) == -1 and snakes(s*2+1) == -1 then next s: goto 4410

4100 r = rnd(1)
4110 if r < 0.25 and snakes(s*2) > 0 then snakes(s*2) = snakes(s*2) - 1: goto 4150
4120 if r < 0.5 and snakes(s*2) < 29 then snakes(s*2) = snakes(s*2) + 1: goto 4150
4130 if r < 0.75 and snakes(s*2+1) > 0 then snakes(s*2+1) = snakes(s*2+1) - 1: goto 4150
4140 if r < 1 and snakes(s*2+1) < 29 then snakes(s*2+1) = snakes(s*2+1) + 1: goto 4150

4150 map(snakes(s*2)*30 + snakes(s*2+1)) = 1

4230 if rnd(1) < difficulty * 0.2 then goto 4260
4240 if rnd(1) < (1 - difficulty) * 0.2 then snakes(s*2) = -1: snakes(s*2+1) = -1
4250 goto 4400

4259 rem splitting code
4260 for ns=0 to 4
4270 if snakes(ns) >< -1 and snakes(1) >< -1 then next s
4280 snakes(ns*2) = snakes(s*2)
4290 snakes(ns*2+1) = snakes(ns*2) + 1

4400 next s

4410 for s=0 to 4
4420 if snakes(s*2) >< -1 and snakes(s*2+1) >< -1 then goto 4080
4430 next s

4500 return

5900 rem subprotocol to draw all existing objects in the frame
5910 rem does not compute occlusion
5920 gosub 5990
5930 gosub 6590
5940 ntriangles = 0
5950 nrectangles = 0
5960 return

5990 if ntriangles == 0 then return
6000 for objecti=0 to ntriangles-1 step 1
6010 x1 = triangles(9 * objecti + 0)
6020 y1 = triangles(9 * objecti + 1)
6030 z1 = triangles(9 * objecti + 2)
6040 x2 = triangles(9 * objecti + 3)
6050 y2 = triangles(9 * objecti + 4)
6060 z2 = triangles(9 * objecti + 5)
6070 x3 = triangles(9 * objecti + 6)
6080 y3 = triangles(9 * objecti + 7)
6090 z3 = triangles(9 * objecti + 8)

6100 tx = x1
6110 ty = y1
6120 tz = z1
6130 gosub 8100
6140 x1 = tx
6150 y1 = ty
6160 z1 = tz

6200 tx = x2
6210 ty = y2
6220 tz = z2
6230 gosub 8100
6240 x2 = tx
6250 y2 = ty
6260 z2 = tz

6300 tx = x3
6310 ty = y3
6320 tz = z3
6330 gosub 8100
6340 x3 = tx
6350 y3 = ty
6360 z3 = tz

6400 x1 = x1 * FOV / z1 + xscreen/2
6410 y1 = y1 * FOV / z1 + yscreen/2
6420 x2 = x2 * FOV / z2 + xscreen/2
6430 y2 = y2 * FOV / z2 + yscreen/2
6440 x3 = x3 * FOV / z3 + xscreen/2
6450 y3 = y3 * FOV / z3 + yscreen/2

6500 sx = x1: sy = y1: ex = x2: ey = y2: gosub 8000
6510 sx = x2: sy = y2: ex = x3: ey = y3: gosub 8000
6520 sx = x1: sy = y1: ex = x3: ey = y3: gosub 8000

6530 next objecti
6540 return

6590 if nrectangles == 0 then return
6600 for objecti=0 to nrectangles-1 step 1
6610 x1 = rectangles(12 * objecti + 0)
6620 y1 = rectangles(12 * objecti + 1)
6630 z1 = rectangles(12 * objecti + 2)
6640 x2 = rectangles(12 * objecti + 3)
6650 y2 = rectangles(12 * objecti + 4)
6660 z2 = rectangles(12 * objecti + 5)
6670 x3 = rectangles(12 * objecti + 6)
6680 y3 = rectangles(12 * objecti + 7)
6690 z3 = rectangles(12 * objecti + 8)
6700 x4 = rectangles(12 * objecti + 9)
6710 y4 = rectangles(12 * objecti + 10)
6720 z4 = rectangles(12 * objecti + 11)

6800 tx = x1
6810 ty = y1
6820 tz = z1
6830 gosub 8100
6840 x1 = tx
6850 y1 = ty
6860 z1 = tz

6900 tx = x2
6910 ty = y2
6920 tz = z2
6930 gosub 8100
6940 x2 = tx
6950 y2 = ty
6960 z2 = tz

7000 tx = x3
7010 ty = y3
7020 tz = z3
7030 gosub 8100
7040 x3 = tx
7050 y3 = ty
7060 z3 = tz

7100 tx = x4
7110 ty = y4
7120 tz = z4
7130 gosub 8100
7140 x4 = tx
7150 y4 = ty
7160 z4 = tz

7200 x1 = x1 * FOV / z1 + xscreen/2
7210 y1 = y1 * FOV / z1 + yscreen/2
7220 x2 = x2 * FOV / z2 + xscreen/2
7230 y2 = y2 * FOV / z2 + yscreen/2
7240 x3 = x3 * FOV / z3 + xscreen/2
7250 y3 = y3 * FOV / z3 + yscreen/2
7260 x4 = x4 * FOV / z4 + xscreen/2
7270 y4 = y4 * FOV / z4 + yscreen/2

7340 sx = x1: sy = y1: ex = x2: ey = y2: gosub 8000
7440 sx = x2: sy = y2: ex = x3: ey = y3: gosub 8000
7540 sx = x3: sy = y3: ex = x4: ey = y4: gosub 8000
7640 sx = x1: sy = y1: ex = x4: ey = y4: gosub 8000

7700 next objecti
7710 return

7998 rem subprotocol to draw a line clipped to screen
7999 rem takes input as sx, sy, ex, ey (start end x y)
8000 if sx > 0 and sx < xscreen and ex > 0 and ex < xscreen and sy > 0 and sy < yscreen and ey > 0 and ey < yscreen then hplot sx, sy to ex, ey
8010 return

8098 rem subprotocol to transform x,y,z coordinates into camera space for drawing
8099 rem takes input as tx, ty, tz (transform x y z)
8100 tx = tx + xcamera
8110 tz = tz + zcamera
8120 ty = ty + ycamera
8130 ox = tx
8140 oz = tz
8150 tx = ox * cos(yrot) - oz * sin(yrot)
8160 tz = ox * sin(yrot) + oz * cos(yrot)
8165 if tz < 0 then tz = 0.0001
8170 return