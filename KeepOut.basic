1 hgr
2 HCOLOR = 3
3 PI = 3.141592653
4 xscreen = 280
5 yscreen = 192

30 dim triangles(12*20)
40 ntriangles = 0
50 dim rectangles(16*20)
60 nrectangles = 0
61 rem to draw a triangle, add the relevant points to triangles -
62 rem x1,y1,z1,x2,y2,z2,x3,y3,z3 - and increment ntriangles
63 rem drawing a rectangle is the analagous with appropriate variables
64 rem the arrays have space for 20 at once

70 xcamera = 0
80 ycamera = 0
90 zcamera = 5
100 yrot = 0
110 FOV = 120
101 rem choosing to ignore x and z rotation as they are not needed for this
102 rem rotation of 0 is in the +z direction; angles are 0-2Ï€
103 rem FOV is linear and represents how many px a meter is

120 triangles(0) = 0
121 triangles(1) = 0
122 triangles(2) = 1

123 triangles(3) = 10
124 triangles(4) = 0
125 triangles(5) = 1

126 triangles(6) = 0
127 triangles(7) = 10
128 triangles(8) = 1

129 ntriangles = 0

130 rectangles(0) = -1
131 rectangles(1) = -1
132 rectangles(2) = 1

133 rectangles(3) = -1
134 rectangles(4) = 1
135 rectangles(5) = 1

136 rectangles(6) = 1
137 rectangles(7) = 1
138 rectangles(8) = 1

139 rectangles(9) = 1
140 rectangles(10) = -1
141 rectangles(11) = 1

142 nrectangles = 1

144 for i=0 to 200
146 yrot = yrot + 0.1
149 HCOLOR = 3
150 gosub 5900
151 HCOLOR = 0
152 gosub 5900
153 next i
160 end

5900 rem subprotocol to draw all existing objects in the frame
5910 rem does not compute occlusion
5920 gosub 5990
5930 gosub 6590
5940 return

5990 if ntriangles == 0 then return
6000 for objecti=0 to ntriangles-1 step 1
6010 x1 = triangles(9 * objecti + 0)
6020 y1 = triangles(9 * objecti + 1)
6030 z1 = triangles(9 * objecti + 2)
6040 x2 = triangles(9 * objecti + 3)
6050 y2 = triangles(9 * objecti + 4)
6060 z2 = triangles(9 * objecti + 5)
6070 x3 = triangles(9 * objecti + 6)
6080 y3 = triangles(9 * objecti + 7)
6090 z3 = triangles(9 * objecti + 8)

6100 tx = x1
6110 ty = y1
6120 tz = z1
6130 gosub 8100
6140 x1 = tx
6150 y1 = ty
6160 z1 = tz

6200 tx = x2
6210 ty = y2
6220 tz = z2
6230 gosub 8100
6240 x2 = tx
6250 y2 = ty
6260 z2 = tz

6300 tx = x3
6310 ty = y3
6320 tz = z3
6330 gosub 8100
6340 x3 = tx
6350 y3 = ty
6360 z3 = tz

6400 x1 = x1 * FOV / z1 + xscreen/2
6410 y1 = y1 * FOV / z1 + yscreen/2
6420 x2 = x2 * FOV / z2 + xscreen/2
6430 y2 = y2 * FOV / z2 + yscreen/2
6440 x3 = x3 * FOV / z3 + xscreen/2
6450 y3 = y3 * FOV / z3 + yscreen/2

6500 sx = x1: sy = y1: ex = x2: ey = y2: gosub 8000
6510 sx = x2: sy = y2: ex = x3: ey = y3: gosub 8000
6520 sx = x1: sy = y1: ex = x3: ey = y3: gosub 8000

6530 next objecti
6540 return

6590 if nrectangles == 0 then return
6600 for objecti=0 to nrectangles-1 step 1
6610 x1 = rectangles(12 * objecti + 0)
6620 y1 = rectangles(12 * objecti + 1)
6630 z1 = rectangles(12 * objecti + 2)
6640 x2 = rectangles(12 * objecti + 3)
6650 y2 = rectangles(12 * objecti + 4)
6660 z2 = rectangles(12 * objecti + 5)
6670 x3 = rectangles(12 * objecti + 6)
6680 y3 = rectangles(12 * objecti + 7)
6690 z3 = rectangles(12 * objecti + 8)
6700 x4 = rectangles(12 * objecti + 9)
6710 y4 = rectangles(12 * objecti + 10)
6720 z4 = rectangles(12 * objecti + 11)

6800 tx = x1
6810 ty = y1
6820 tz = z1
6830 gosub 8100
6840 x1 = tx
6850 y1 = ty
6860 z1 = tz

6900 tx = x2
6910 ty = y2
6920 tz = z2
6930 gosub 8100
6940 x2 = tx
6950 y2 = ty
6960 z2 = tz

7000 tx = x3
7010 ty = y3
7020 tz = z3
7030 gosub 8100
7040 x3 = tx
7050 y3 = ty
7060 z3 = tz

7100 tx = x4
7110 ty = y4
7120 tz = z4
7130 gosub 8100
7140 x4 = tx
7150 y4 = ty
7160 z4 = tz

7200 x1 = x1 * FOV / z1 + xscreen/2
7210 y1 = y1 * FOV / z1 + yscreen/2
7220 x2 = x2 * FOV / z2 + xscreen/2
7230 y2 = y2 * FOV / z2 + yscreen/2
7240 x3 = x3 * FOV / z3 + xscreen/2
7250 y3 = y3 * FOV / z3 + yscreen/2
7260 x4 = x4 * FOV / z4 + xscreen/2
7270 y4 = y4 * FOV / z4 + yscreen/2

7340 sx = x1: sy = y1: ex = x2: ey = y2: gosub 8000
7440 sx = x2: sy = y2: ex = x3: ey = y3: gosub 8000
7540 sx = x3: sy = y3: ex = x4: ey = y4: gosub 8000
7640 sx = x1: sy = y1: ex = x4: ey = y4: gosub 8000

7700 next objecti
7710 return

7998 rem subprotocol to draw a line clipped to screen
7999 rem takes input as sx, sy, ex, ey (start end x y)
8000 if sx > 0 and sx < xscreen and ex > 0 and ex < xscreen and sy > 0 and sy < yscreen and ey > 0 and ey < yscreen then hplot sx, sy to ex, ey
8010 return

8098 rem subprotocol to transform x,y,z coordinates into camera space for drawing
8099 rem takes input as tx, ty, tz (transform x y z)
8100 tx = tx + xcamera
8110 tz = tz + zcamera
8120 ty = ty + ycamera
8130 ox = tx
8140 oz = tz
8150 tx = ox * cos(yrot) - oz * sin(yrot)
8160 tz = ox * sin(yrot) + oz * cos(yrot)
8165 if tz < 0 then tz = 0.0001
8170 return